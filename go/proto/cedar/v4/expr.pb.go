// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: cedar/v4/expr.proto

package cedarv4

import (
	_ "github.com/celest-dev/corks/go/proto/dart_options"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Variable int32

const (
	Variable_VARIABLE_UNSPECIFIED Variable = 0
	Variable_VARIABLE_PRINCIPAL   Variable = 1
	Variable_VARIABLE_ACTION      Variable = 2
	Variable_VARIABLE_RESOURCE    Variable = 3
	Variable_VARIABLE_CONTEXT     Variable = 4
)

// Enum value maps for Variable.
var (
	Variable_name = map[int32]string{
		0: "VARIABLE_UNSPECIFIED",
		1: "VARIABLE_PRINCIPAL",
		2: "VARIABLE_ACTION",
		3: "VARIABLE_RESOURCE",
		4: "VARIABLE_CONTEXT",
	}
	Variable_value = map[string]int32{
		"VARIABLE_UNSPECIFIED": 0,
		"VARIABLE_PRINCIPAL":   1,
		"VARIABLE_ACTION":      2,
		"VARIABLE_RESOURCE":    3,
		"VARIABLE_CONTEXT":     4,
	}
)

func (x Variable) Enum() *Variable {
	p := new(Variable)
	*p = x
	return p
}

func (x Variable) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Variable) Descriptor() protoreflect.EnumDescriptor {
	return file_cedar_v4_expr_proto_enumTypes[0].Descriptor()
}

func (Variable) Type() protoreflect.EnumType {
	return &file_cedar_v4_expr_proto_enumTypes[0]
}

func (x Variable) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Variable.Descriptor instead.
func (Variable) EnumDescriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{0}
}

type SlotId int32

const (
	SlotId_SLOT_ID_UNSPECIFIED SlotId = 0
	SlotId_SLOT_ID_PRINCIPAL   SlotId = 1
	SlotId_SLOT_ID_RESOURCE    SlotId = 2
)

// Enum value maps for SlotId.
var (
	SlotId_name = map[int32]string{
		0: "SLOT_ID_UNSPECIFIED",
		1: "SLOT_ID_PRINCIPAL",
		2: "SLOT_ID_RESOURCE",
	}
	SlotId_value = map[string]int32{
		"SLOT_ID_UNSPECIFIED": 0,
		"SLOT_ID_PRINCIPAL":   1,
		"SLOT_ID_RESOURCE":    2,
	}
)

func (x SlotId) Enum() *SlotId {
	p := new(SlotId)
	*p = x
	return p
}

func (x SlotId) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SlotId) Descriptor() protoreflect.EnumDescriptor {
	return file_cedar_v4_expr_proto_enumTypes[1].Descriptor()
}

func (SlotId) Type() protoreflect.EnumType {
	return &file_cedar_v4_expr_proto_enumTypes[1]
}

func (x SlotId) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SlotId.Descriptor instead.
func (SlotId) EnumDescriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{1}
}

type Expr struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Expr:
	//
	//	*Expr_Value
	//	*Expr_Variable
	//	*Expr_Slot
	//	*Expr_Unknown
	//	*Expr_Not
	//	*Expr_Negate
	//	*Expr_Equals
	//	*Expr_NotEquals
	//	*Expr_In
	//	*Expr_LessThan
	//	*Expr_LessThanOrEquals
	//	*Expr_GreaterThan
	//	*Expr_GreaterThanOrEquals
	//	*Expr_And
	//	*Expr_Or
	//	*Expr_Add
	//	*Expr_Subtract
	//	*Expr_Multiply
	//	*Expr_Contains
	//	*Expr_ContainsAll
	//	*Expr_ContainsAny
	//	*Expr_GetAttribute
	//	*Expr_HasAttribute
	//	*Expr_Like
	//	*Expr_Is
	//	*Expr_IfThenElse
	//	*Expr_Set
	//	*Expr_Record
	//	*Expr_ExtensionCall
	//	*Expr_GetTag
	//	*Expr_HasTag
	Expr          isExpr_Expr `protobuf_oneof:"expr"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Expr) Reset() {
	*x = Expr{}
	mi := &file_cedar_v4_expr_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Expr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Expr) ProtoMessage() {}

func (x *Expr) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Expr.ProtoReflect.Descriptor instead.
func (*Expr) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{0}
}

func (x *Expr) GetExpr() isExpr_Expr {
	if x != nil {
		return x.Expr
	}
	return nil
}

func (x *Expr) GetValue() *ExprValue {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Value); ok {
			return x.Value
		}
	}
	return nil
}

func (x *Expr) GetVariable() *ExprVariable {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Variable); ok {
			return x.Variable
		}
	}
	return nil
}

func (x *Expr) GetSlot() *ExprSlot {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Slot); ok {
			return x.Slot
		}
	}
	return nil
}

func (x *Expr) GetUnknown() *ExprUnknown {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Unknown); ok {
			return x.Unknown
		}
	}
	return nil
}

func (x *Expr) GetNot() *ExprNot {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Not); ok {
			return x.Not
		}
	}
	return nil
}

func (x *Expr) GetNegate() *ExprNegate {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Negate); ok {
			return x.Negate
		}
	}
	return nil
}

func (x *Expr) GetEquals() *ExprEquals {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Equals); ok {
			return x.Equals
		}
	}
	return nil
}

func (x *Expr) GetNotEquals() *ExprNotEquals {
	if x != nil {
		if x, ok := x.Expr.(*Expr_NotEquals); ok {
			return x.NotEquals
		}
	}
	return nil
}

func (x *Expr) GetIn() *ExprIn {
	if x != nil {
		if x, ok := x.Expr.(*Expr_In); ok {
			return x.In
		}
	}
	return nil
}

func (x *Expr) GetLessThan() *ExprLessThan {
	if x != nil {
		if x, ok := x.Expr.(*Expr_LessThan); ok {
			return x.LessThan
		}
	}
	return nil
}

func (x *Expr) GetLessThanOrEquals() *ExprLessThanOrEquals {
	if x != nil {
		if x, ok := x.Expr.(*Expr_LessThanOrEquals); ok {
			return x.LessThanOrEquals
		}
	}
	return nil
}

func (x *Expr) GetGreaterThan() *ExprGreaterThan {
	if x != nil {
		if x, ok := x.Expr.(*Expr_GreaterThan); ok {
			return x.GreaterThan
		}
	}
	return nil
}

func (x *Expr) GetGreaterThanOrEquals() *ExprGreaterThanOrEquals {
	if x != nil {
		if x, ok := x.Expr.(*Expr_GreaterThanOrEquals); ok {
			return x.GreaterThanOrEquals
		}
	}
	return nil
}

func (x *Expr) GetAnd() *ExprAnd {
	if x != nil {
		if x, ok := x.Expr.(*Expr_And); ok {
			return x.And
		}
	}
	return nil
}

func (x *Expr) GetOr() *ExprOr {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Or); ok {
			return x.Or
		}
	}
	return nil
}

func (x *Expr) GetAdd() *ExprAdd {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Add); ok {
			return x.Add
		}
	}
	return nil
}

func (x *Expr) GetSubtract() *ExprSubt {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Subtract); ok {
			return x.Subtract
		}
	}
	return nil
}

func (x *Expr) GetMultiply() *ExprMult {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Multiply); ok {
			return x.Multiply
		}
	}
	return nil
}

func (x *Expr) GetContains() *ExprContains {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Contains); ok {
			return x.Contains
		}
	}
	return nil
}

func (x *Expr) GetContainsAll() *ExprContainsAll {
	if x != nil {
		if x, ok := x.Expr.(*Expr_ContainsAll); ok {
			return x.ContainsAll
		}
	}
	return nil
}

func (x *Expr) GetContainsAny() *ExprContainsAny {
	if x != nil {
		if x, ok := x.Expr.(*Expr_ContainsAny); ok {
			return x.ContainsAny
		}
	}
	return nil
}

func (x *Expr) GetGetAttribute() *ExprGetAttribute {
	if x != nil {
		if x, ok := x.Expr.(*Expr_GetAttribute); ok {
			return x.GetAttribute
		}
	}
	return nil
}

func (x *Expr) GetHasAttribute() *ExprHasAttribute {
	if x != nil {
		if x, ok := x.Expr.(*Expr_HasAttribute); ok {
			return x.HasAttribute
		}
	}
	return nil
}

func (x *Expr) GetLike() *ExprLike {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Like); ok {
			return x.Like
		}
	}
	return nil
}

func (x *Expr) GetIs() *ExprIs {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Is); ok {
			return x.Is
		}
	}
	return nil
}

func (x *Expr) GetIfThenElse() *ExprIfThenElse {
	if x != nil {
		if x, ok := x.Expr.(*Expr_IfThenElse); ok {
			return x.IfThenElse
		}
	}
	return nil
}

func (x *Expr) GetSet() *ExprSet {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Set); ok {
			return x.Set
		}
	}
	return nil
}

func (x *Expr) GetRecord() *ExprRecord {
	if x != nil {
		if x, ok := x.Expr.(*Expr_Record); ok {
			return x.Record
		}
	}
	return nil
}

func (x *Expr) GetExtensionCall() *ExprExtensionCall {
	if x != nil {
		if x, ok := x.Expr.(*Expr_ExtensionCall); ok {
			return x.ExtensionCall
		}
	}
	return nil
}

func (x *Expr) GetGetTag() *ExprGetTag {
	if x != nil {
		if x, ok := x.Expr.(*Expr_GetTag); ok {
			return x.GetTag
		}
	}
	return nil
}

func (x *Expr) GetHasTag() *ExprHasTag {
	if x != nil {
		if x, ok := x.Expr.(*Expr_HasTag); ok {
			return x.HasTag
		}
	}
	return nil
}

type isExpr_Expr interface {
	isExpr_Expr()
}

type Expr_Value struct {
	Value *ExprValue `protobuf:"bytes,1,opt,name=value,proto3,oneof"`
}

type Expr_Variable struct {
	Variable *ExprVariable `protobuf:"bytes,2,opt,name=variable,proto3,oneof"`
}

type Expr_Slot struct {
	Slot *ExprSlot `protobuf:"bytes,3,opt,name=slot,proto3,oneof"`
}

type Expr_Unknown struct {
	Unknown *ExprUnknown `protobuf:"bytes,4,opt,name=unknown,proto3,oneof"`
}

type Expr_Not struct {
	Not *ExprNot `protobuf:"bytes,5,opt,name=not,proto3,oneof"`
}

type Expr_Negate struct {
	Negate *ExprNegate `protobuf:"bytes,6,opt,name=negate,proto3,oneof"`
}

type Expr_Equals struct {
	Equals *ExprEquals `protobuf:"bytes,7,opt,name=equals,proto3,oneof"`
}

type Expr_NotEquals struct {
	NotEquals *ExprNotEquals `protobuf:"bytes,8,opt,name=not_equals,json=notEquals,proto3,oneof"`
}

type Expr_In struct {
	In *ExprIn `protobuf:"bytes,9,opt,name=in,proto3,oneof"`
}

type Expr_LessThan struct {
	LessThan *ExprLessThan `protobuf:"bytes,10,opt,name=less_than,json=lessThan,proto3,oneof"`
}

type Expr_LessThanOrEquals struct {
	LessThanOrEquals *ExprLessThanOrEquals `protobuf:"bytes,11,opt,name=less_than_or_equals,json=lessThanOrEquals,proto3,oneof"`
}

type Expr_GreaterThan struct {
	GreaterThan *ExprGreaterThan `protobuf:"bytes,12,opt,name=greater_than,json=greaterThan,proto3,oneof"`
}

type Expr_GreaterThanOrEquals struct {
	GreaterThanOrEquals *ExprGreaterThanOrEquals `protobuf:"bytes,13,opt,name=greater_than_or_equals,json=greaterThanOrEquals,proto3,oneof"`
}

type Expr_And struct {
	And *ExprAnd `protobuf:"bytes,14,opt,name=and,proto3,oneof"`
}

type Expr_Or struct {
	Or *ExprOr `protobuf:"bytes,15,opt,name=or,proto3,oneof"`
}

type Expr_Add struct {
	Add *ExprAdd `protobuf:"bytes,16,opt,name=add,proto3,oneof"`
}

type Expr_Subtract struct {
	Subtract *ExprSubt `protobuf:"bytes,17,opt,name=subtract,proto3,oneof"`
}

type Expr_Multiply struct {
	Multiply *ExprMult `protobuf:"bytes,18,opt,name=multiply,proto3,oneof"`
}

type Expr_Contains struct {
	Contains *ExprContains `protobuf:"bytes,19,opt,name=contains,proto3,oneof"`
}

type Expr_ContainsAll struct {
	ContainsAll *ExprContainsAll `protobuf:"bytes,20,opt,name=contains_all,json=containsAll,proto3,oneof"`
}

type Expr_ContainsAny struct {
	ContainsAny *ExprContainsAny `protobuf:"bytes,21,opt,name=contains_any,json=containsAny,proto3,oneof"`
}

type Expr_GetAttribute struct {
	GetAttribute *ExprGetAttribute `protobuf:"bytes,22,opt,name=get_attribute,json=getAttribute,proto3,oneof"`
}

type Expr_HasAttribute struct {
	HasAttribute *ExprHasAttribute `protobuf:"bytes,23,opt,name=has_attribute,json=hasAttribute,proto3,oneof"`
}

type Expr_Like struct {
	Like *ExprLike `protobuf:"bytes,24,opt,name=like,proto3,oneof"`
}

type Expr_Is struct {
	Is *ExprIs `protobuf:"bytes,25,opt,name=is,proto3,oneof"`
}

type Expr_IfThenElse struct {
	IfThenElse *ExprIfThenElse `protobuf:"bytes,26,opt,name=if_then_else,json=ifThenElse,proto3,oneof"`
}

type Expr_Set struct {
	Set *ExprSet `protobuf:"bytes,27,opt,name=set,proto3,oneof"`
}

type Expr_Record struct {
	Record *ExprRecord `protobuf:"bytes,28,opt,name=record,proto3,oneof"`
}

type Expr_ExtensionCall struct {
	ExtensionCall *ExprExtensionCall `protobuf:"bytes,29,opt,name=extension_call,json=extensionCall,proto3,oneof"`
}

type Expr_GetTag struct {
	GetTag *ExprGetTag `protobuf:"bytes,30,opt,name=get_tag,json=getTag,proto3,oneof"`
}

type Expr_HasTag struct {
	HasTag *ExprHasTag `protobuf:"bytes,31,opt,name=has_tag,json=hasTag,proto3,oneof"`
}

func (*Expr_Value) isExpr_Expr() {}

func (*Expr_Variable) isExpr_Expr() {}

func (*Expr_Slot) isExpr_Expr() {}

func (*Expr_Unknown) isExpr_Expr() {}

func (*Expr_Not) isExpr_Expr() {}

func (*Expr_Negate) isExpr_Expr() {}

func (*Expr_Equals) isExpr_Expr() {}

func (*Expr_NotEquals) isExpr_Expr() {}

func (*Expr_In) isExpr_Expr() {}

func (*Expr_LessThan) isExpr_Expr() {}

func (*Expr_LessThanOrEquals) isExpr_Expr() {}

func (*Expr_GreaterThan) isExpr_Expr() {}

func (*Expr_GreaterThanOrEquals) isExpr_Expr() {}

func (*Expr_And) isExpr_Expr() {}

func (*Expr_Or) isExpr_Expr() {}

func (*Expr_Add) isExpr_Expr() {}

func (*Expr_Subtract) isExpr_Expr() {}

func (*Expr_Multiply) isExpr_Expr() {}

func (*Expr_Contains) isExpr_Expr() {}

func (*Expr_ContainsAll) isExpr_Expr() {}

func (*Expr_ContainsAny) isExpr_Expr() {}

func (*Expr_GetAttribute) isExpr_Expr() {}

func (*Expr_HasAttribute) isExpr_Expr() {}

func (*Expr_Like) isExpr_Expr() {}

func (*Expr_Is) isExpr_Expr() {}

func (*Expr_IfThenElse) isExpr_Expr() {}

func (*Expr_Set) isExpr_Expr() {}

func (*Expr_Record) isExpr_Expr() {}

func (*Expr_ExtensionCall) isExpr_Expr() {}

func (*Expr_GetTag) isExpr_Expr() {}

func (*Expr_HasTag) isExpr_Expr() {}

type ExprValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *Value                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprValue) Reset() {
	*x = ExprValue{}
	mi := &file_cedar_v4_expr_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprValue) ProtoMessage() {}

func (x *ExprValue) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprValue.ProtoReflect.Descriptor instead.
func (*ExprValue) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{1}
}

func (x *ExprValue) GetValue() *Value {
	if x != nil {
		return x.Value
	}
	return nil
}

type ExprVariable struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Variable      Variable               `protobuf:"varint,1,opt,name=variable,proto3,enum=cedar.v4.Variable" json:"variable,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprVariable) Reset() {
	*x = ExprVariable{}
	mi := &file_cedar_v4_expr_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprVariable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprVariable) ProtoMessage() {}

func (x *ExprVariable) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprVariable.ProtoReflect.Descriptor instead.
func (*ExprVariable) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{2}
}

func (x *ExprVariable) GetVariable() Variable {
	if x != nil {
		return x.Variable
	}
	return Variable_VARIABLE_UNSPECIFIED
}

type ExprSlot struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SlotId        SlotId                 `protobuf:"varint,1,opt,name=slot_id,json=slotId,proto3,enum=cedar.v4.SlotId" json:"slot_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprSlot) Reset() {
	*x = ExprSlot{}
	mi := &file_cedar_v4_expr_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprSlot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprSlot) ProtoMessage() {}

func (x *ExprSlot) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprSlot.ProtoReflect.Descriptor instead.
func (*ExprSlot) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{3}
}

func (x *ExprSlot) GetSlotId() SlotId {
	if x != nil {
		return x.SlotId
	}
	return SlotId_SLOT_ID_UNSPECIFIED
}

type ExprUnknown struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprUnknown) Reset() {
	*x = ExprUnknown{}
	mi := &file_cedar_v4_expr_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprUnknown) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprUnknown) ProtoMessage() {}

func (x *ExprUnknown) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprUnknown.ProtoReflect.Descriptor instead.
func (*ExprUnknown) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{4}
}

func (x *ExprUnknown) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type ExprNot struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Arg           *Expr                  `protobuf:"bytes,1,opt,name=arg,proto3" json:"arg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprNot) Reset() {
	*x = ExprNot{}
	mi := &file_cedar_v4_expr_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprNot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprNot) ProtoMessage() {}

func (x *ExprNot) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprNot.ProtoReflect.Descriptor instead.
func (*ExprNot) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{5}
}

func (x *ExprNot) GetArg() *Expr {
	if x != nil {
		return x.Arg
	}
	return nil
}

type ExprNegate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Arg           *Expr                  `protobuf:"bytes,1,opt,name=arg,proto3" json:"arg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprNegate) Reset() {
	*x = ExprNegate{}
	mi := &file_cedar_v4_expr_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprNegate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprNegate) ProtoMessage() {}

func (x *ExprNegate) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprNegate.ProtoReflect.Descriptor instead.
func (*ExprNegate) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{6}
}

func (x *ExprNegate) GetArg() *Expr {
	if x != nil {
		return x.Arg
	}
	return nil
}

type ExprEquals struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprEquals) Reset() {
	*x = ExprEquals{}
	mi := &file_cedar_v4_expr_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprEquals) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprEquals) ProtoMessage() {}

func (x *ExprEquals) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprEquals.ProtoReflect.Descriptor instead.
func (*ExprEquals) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{7}
}

func (x *ExprEquals) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprEquals) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprNotEquals struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprNotEquals) Reset() {
	*x = ExprNotEquals{}
	mi := &file_cedar_v4_expr_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprNotEquals) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprNotEquals) ProtoMessage() {}

func (x *ExprNotEquals) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprNotEquals.ProtoReflect.Descriptor instead.
func (*ExprNotEquals) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{8}
}

func (x *ExprNotEquals) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprNotEquals) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprIn struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprIn) Reset() {
	*x = ExprIn{}
	mi := &file_cedar_v4_expr_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprIn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprIn) ProtoMessage() {}

func (x *ExprIn) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprIn.ProtoReflect.Descriptor instead.
func (*ExprIn) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{9}
}

func (x *ExprIn) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprIn) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprLessThan struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprLessThan) Reset() {
	*x = ExprLessThan{}
	mi := &file_cedar_v4_expr_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprLessThan) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprLessThan) ProtoMessage() {}

func (x *ExprLessThan) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprLessThan.ProtoReflect.Descriptor instead.
func (*ExprLessThan) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{10}
}

func (x *ExprLessThan) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprLessThan) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprLessThanOrEquals struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprLessThanOrEquals) Reset() {
	*x = ExprLessThanOrEquals{}
	mi := &file_cedar_v4_expr_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprLessThanOrEquals) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprLessThanOrEquals) ProtoMessage() {}

func (x *ExprLessThanOrEquals) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprLessThanOrEquals.ProtoReflect.Descriptor instead.
func (*ExprLessThanOrEquals) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{11}
}

func (x *ExprLessThanOrEquals) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprLessThanOrEquals) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprGreaterThan struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprGreaterThan) Reset() {
	*x = ExprGreaterThan{}
	mi := &file_cedar_v4_expr_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprGreaterThan) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprGreaterThan) ProtoMessage() {}

func (x *ExprGreaterThan) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprGreaterThan.ProtoReflect.Descriptor instead.
func (*ExprGreaterThan) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{12}
}

func (x *ExprGreaterThan) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprGreaterThan) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprGreaterThanOrEquals struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprGreaterThanOrEquals) Reset() {
	*x = ExprGreaterThanOrEquals{}
	mi := &file_cedar_v4_expr_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprGreaterThanOrEquals) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprGreaterThanOrEquals) ProtoMessage() {}

func (x *ExprGreaterThanOrEquals) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprGreaterThanOrEquals.ProtoReflect.Descriptor instead.
func (*ExprGreaterThanOrEquals) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{13}
}

func (x *ExprGreaterThanOrEquals) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprGreaterThanOrEquals) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprAnd struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprAnd) Reset() {
	*x = ExprAnd{}
	mi := &file_cedar_v4_expr_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprAnd) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprAnd) ProtoMessage() {}

func (x *ExprAnd) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprAnd.ProtoReflect.Descriptor instead.
func (*ExprAnd) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{14}
}

func (x *ExprAnd) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprAnd) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprOr struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprOr) Reset() {
	*x = ExprOr{}
	mi := &file_cedar_v4_expr_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprOr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprOr) ProtoMessage() {}

func (x *ExprOr) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprOr.ProtoReflect.Descriptor instead.
func (*ExprOr) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{15}
}

func (x *ExprOr) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprOr) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprAdd struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprAdd) Reset() {
	*x = ExprAdd{}
	mi := &file_cedar_v4_expr_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprAdd) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprAdd) ProtoMessage() {}

func (x *ExprAdd) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprAdd.ProtoReflect.Descriptor instead.
func (*ExprAdd) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{16}
}

func (x *ExprAdd) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprAdd) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprSubt struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprSubt) Reset() {
	*x = ExprSubt{}
	mi := &file_cedar_v4_expr_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprSubt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprSubt) ProtoMessage() {}

func (x *ExprSubt) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprSubt.ProtoReflect.Descriptor instead.
func (*ExprSubt) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{17}
}

func (x *ExprSubt) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprSubt) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprMult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprMult) Reset() {
	*x = ExprMult{}
	mi := &file_cedar_v4_expr_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprMult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprMult) ProtoMessage() {}

func (x *ExprMult) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprMult.ProtoReflect.Descriptor instead.
func (*ExprMult) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{18}
}

func (x *ExprMult) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprMult) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprContains struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprContains) Reset() {
	*x = ExprContains{}
	mi := &file_cedar_v4_expr_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprContains) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprContains) ProtoMessage() {}

func (x *ExprContains) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprContains.ProtoReflect.Descriptor instead.
func (*ExprContains) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{19}
}

func (x *ExprContains) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprContains) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprContainsAll struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprContainsAll) Reset() {
	*x = ExprContainsAll{}
	mi := &file_cedar_v4_expr_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprContainsAll) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprContainsAll) ProtoMessage() {}

func (x *ExprContainsAll) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprContainsAll.ProtoReflect.Descriptor instead.
func (*ExprContainsAll) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{20}
}

func (x *ExprContainsAll) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprContainsAll) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprContainsAny struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right         *Expr                  `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprContainsAny) Reset() {
	*x = ExprContainsAny{}
	mi := &file_cedar_v4_expr_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprContainsAny) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprContainsAny) ProtoMessage() {}

func (x *ExprContainsAny) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprContainsAny.ProtoReflect.Descriptor instead.
func (*ExprContainsAny) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{21}
}

func (x *ExprContainsAny) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprContainsAny) GetRight() *Expr {
	if x != nil {
		return x.Right
	}
	return nil
}

type ExprGetAttribute struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Attr          string                 `protobuf:"bytes,2,opt,name=attr,proto3" json:"attr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprGetAttribute) Reset() {
	*x = ExprGetAttribute{}
	mi := &file_cedar_v4_expr_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprGetAttribute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprGetAttribute) ProtoMessage() {}

func (x *ExprGetAttribute) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprGetAttribute.ProtoReflect.Descriptor instead.
func (*ExprGetAttribute) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{22}
}

func (x *ExprGetAttribute) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprGetAttribute) GetAttr() string {
	if x != nil {
		return x.Attr
	}
	return ""
}

type ExprHasAttribute struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Attr          string                 `protobuf:"bytes,2,opt,name=attr,proto3" json:"attr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprHasAttribute) Reset() {
	*x = ExprHasAttribute{}
	mi := &file_cedar_v4_expr_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprHasAttribute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprHasAttribute) ProtoMessage() {}

func (x *ExprHasAttribute) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprHasAttribute.ProtoReflect.Descriptor instead.
func (*ExprHasAttribute) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{23}
}

func (x *ExprHasAttribute) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprHasAttribute) GetAttr() string {
	if x != nil {
		return x.Attr
	}
	return ""
}

type ExprGetTag struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Tag           *Expr                  `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprGetTag) Reset() {
	*x = ExprGetTag{}
	mi := &file_cedar_v4_expr_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprGetTag) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprGetTag) ProtoMessage() {}

func (x *ExprGetTag) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprGetTag.ProtoReflect.Descriptor instead.
func (*ExprGetTag) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{24}
}

func (x *ExprGetTag) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprGetTag) GetTag() *Expr {
	if x != nil {
		return x.Tag
	}
	return nil
}

type ExprHasTag struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Tag           *Expr                  `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprHasTag) Reset() {
	*x = ExprHasTag{}
	mi := &file_cedar_v4_expr_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprHasTag) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprHasTag) ProtoMessage() {}

func (x *ExprHasTag) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprHasTag.ProtoReflect.Descriptor instead.
func (*ExprHasTag) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{25}
}

func (x *ExprHasTag) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprHasTag) GetTag() *Expr {
	if x != nil {
		return x.Tag
	}
	return nil
}

type ExprLike struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Pattern       string                 `protobuf:"bytes,2,opt,name=pattern,proto3" json:"pattern,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprLike) Reset() {
	*x = ExprLike{}
	mi := &file_cedar_v4_expr_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprLike) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprLike) ProtoMessage() {}

func (x *ExprLike) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprLike.ProtoReflect.Descriptor instead.
func (*ExprLike) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{26}
}

func (x *ExprLike) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprLike) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

type ExprIs struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Left          *Expr                  `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	EntityType    string                 `protobuf:"bytes,2,opt,name=entity_type,json=entityType,proto3" json:"entity_type,omitempty"`
	In            *Expr                  `protobuf:"bytes,3,opt,name=in,proto3,oneof" json:"in,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprIs) Reset() {
	*x = ExprIs{}
	mi := &file_cedar_v4_expr_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprIs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprIs) ProtoMessage() {}

func (x *ExprIs) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprIs.ProtoReflect.Descriptor instead.
func (*ExprIs) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{27}
}

func (x *ExprIs) GetLeft() *Expr {
	if x != nil {
		return x.Left
	}
	return nil
}

func (x *ExprIs) GetEntityType() string {
	if x != nil {
		return x.EntityType
	}
	return ""
}

func (x *ExprIs) GetIn() *Expr {
	if x != nil {
		return x.In
	}
	return nil
}

type ExprIfThenElse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cond          *Expr                  `protobuf:"bytes,1,opt,name=cond,proto3" json:"cond,omitempty"`
	Then          *Expr                  `protobuf:"bytes,2,opt,name=then,proto3" json:"then,omitempty"`
	Otherwise     *Expr                  `protobuf:"bytes,3,opt,name=otherwise,proto3" json:"otherwise,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprIfThenElse) Reset() {
	*x = ExprIfThenElse{}
	mi := &file_cedar_v4_expr_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprIfThenElse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprIfThenElse) ProtoMessage() {}

func (x *ExprIfThenElse) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprIfThenElse.ProtoReflect.Descriptor instead.
func (*ExprIfThenElse) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{28}
}

func (x *ExprIfThenElse) GetCond() *Expr {
	if x != nil {
		return x.Cond
	}
	return nil
}

func (x *ExprIfThenElse) GetThen() *Expr {
	if x != nil {
		return x.Then
	}
	return nil
}

func (x *ExprIfThenElse) GetOtherwise() *Expr {
	if x != nil {
		return x.Otherwise
	}
	return nil
}

type ExprSet struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Expressions   []*Expr                `protobuf:"bytes,1,rep,name=expressions,proto3" json:"expressions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprSet) Reset() {
	*x = ExprSet{}
	mi := &file_cedar_v4_expr_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprSet) ProtoMessage() {}

func (x *ExprSet) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprSet.ProtoReflect.Descriptor instead.
func (*ExprSet) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{29}
}

func (x *ExprSet) GetExpressions() []*Expr {
	if x != nil {
		return x.Expressions
	}
	return nil
}

type ExprRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Attributes    map[string]*Expr       `protobuf:"bytes,1,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprRecord) Reset() {
	*x = ExprRecord{}
	mi := &file_cedar_v4_expr_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprRecord) ProtoMessage() {}

func (x *ExprRecord) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprRecord.ProtoReflect.Descriptor instead.
func (*ExprRecord) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{30}
}

func (x *ExprRecord) GetAttributes() map[string]*Expr {
	if x != nil {
		return x.Attributes
	}
	return nil
}

type ExprExtensionCall struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fn            string                 `protobuf:"bytes,1,opt,name=fn,proto3" json:"fn,omitempty"`
	Args          []*Expr                `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExprExtensionCall) Reset() {
	*x = ExprExtensionCall{}
	mi := &file_cedar_v4_expr_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExprExtensionCall) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExprExtensionCall) ProtoMessage() {}

func (x *ExprExtensionCall) ProtoReflect() protoreflect.Message {
	mi := &file_cedar_v4_expr_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExprExtensionCall.ProtoReflect.Descriptor instead.
func (*ExprExtensionCall) Descriptor() ([]byte, []int) {
	return file_cedar_v4_expr_proto_rawDescGZIP(), []int{31}
}

func (x *ExprExtensionCall) GetFn() string {
	if x != nil {
		return x.Fn
	}
	return ""
}

func (x *ExprExtensionCall) GetArgs() []*Expr {
	if x != nil {
		return x.Args
	}
	return nil
}

var File_cedar_v4_expr_proto protoreflect.FileDescriptor

const file_cedar_v4_expr_proto_rawDesc = "" +
	"\n" +
	"\x13cedar/v4/expr.proto\x12\bcedar.v4\x1a\x14cedar/v4/value.proto\x1a\x1fdart_options/dart_options.proto\"\x86\r\n" +
	"\x04Expr\x12+\n" +
	"\x05value\x18\x01 \x01(\v2\x13.cedar.v4.ExprValueH\x00R\x05value\x124\n" +
	"\bvariable\x18\x02 \x01(\v2\x16.cedar.v4.ExprVariableH\x00R\bvariable\x12(\n" +
	"\x04slot\x18\x03 \x01(\v2\x12.cedar.v4.ExprSlotH\x00R\x04slot\x121\n" +
	"\aunknown\x18\x04 \x01(\v2\x15.cedar.v4.ExprUnknownH\x00R\aunknown\x12%\n" +
	"\x03not\x18\x05 \x01(\v2\x11.cedar.v4.ExprNotH\x00R\x03not\x12.\n" +
	"\x06negate\x18\x06 \x01(\v2\x14.cedar.v4.ExprNegateH\x00R\x06negate\x12.\n" +
	"\x06equals\x18\a \x01(\v2\x14.cedar.v4.ExprEqualsH\x00R\x06equals\x128\n" +
	"\n" +
	"not_equals\x18\b \x01(\v2\x17.cedar.v4.ExprNotEqualsH\x00R\tnotEquals\x12,\n" +
	"\x02in\x18\t \x01(\v2\x10.cedar.v4.ExprInB\b\xba\x8f\xbem\x03in_H\x00R\x02in\x125\n" +
	"\tless_than\x18\n" +
	" \x01(\v2\x16.cedar.v4.ExprLessThanH\x00R\blessThan\x12O\n" +
	"\x13less_than_or_equals\x18\v \x01(\v2\x1e.cedar.v4.ExprLessThanOrEqualsH\x00R\x10lessThanOrEquals\x12>\n" +
	"\fgreater_than\x18\f \x01(\v2\x19.cedar.v4.ExprGreaterThanH\x00R\vgreaterThan\x12X\n" +
	"\x16greater_than_or_equals\x18\r \x01(\v2!.cedar.v4.ExprGreaterThanOrEqualsH\x00R\x13greaterThanOrEquals\x12%\n" +
	"\x03and\x18\x0e \x01(\v2\x11.cedar.v4.ExprAndH\x00R\x03and\x12\"\n" +
	"\x02or\x18\x0f \x01(\v2\x10.cedar.v4.ExprOrH\x00R\x02or\x12%\n" +
	"\x03add\x18\x10 \x01(\v2\x11.cedar.v4.ExprAddH\x00R\x03add\x120\n" +
	"\bsubtract\x18\x11 \x01(\v2\x12.cedar.v4.ExprSubtH\x00R\bsubtract\x120\n" +
	"\bmultiply\x18\x12 \x01(\v2\x12.cedar.v4.ExprMultH\x00R\bmultiply\x124\n" +
	"\bcontains\x18\x13 \x01(\v2\x16.cedar.v4.ExprContainsH\x00R\bcontains\x12>\n" +
	"\fcontains_all\x18\x14 \x01(\v2\x19.cedar.v4.ExprContainsAllH\x00R\vcontainsAll\x12>\n" +
	"\fcontains_any\x18\x15 \x01(\v2\x19.cedar.v4.ExprContainsAnyH\x00R\vcontainsAny\x12A\n" +
	"\rget_attribute\x18\x16 \x01(\v2\x1a.cedar.v4.ExprGetAttributeH\x00R\fgetAttribute\x12A\n" +
	"\rhas_attribute\x18\x17 \x01(\v2\x1a.cedar.v4.ExprHasAttributeH\x00R\fhasAttribute\x12(\n" +
	"\x04like\x18\x18 \x01(\v2\x12.cedar.v4.ExprLikeH\x00R\x04like\x12,\n" +
	"\x02is\x18\x19 \x01(\v2\x10.cedar.v4.ExprIsB\b\xba\x8f\xbem\x03is_H\x00R\x02is\x12<\n" +
	"\fif_then_else\x18\x1a \x01(\v2\x18.cedar.v4.ExprIfThenElseH\x00R\n" +
	"ifThenElse\x12%\n" +
	"\x03set\x18\x1b \x01(\v2\x11.cedar.v4.ExprSetH\x00R\x03set\x12.\n" +
	"\x06record\x18\x1c \x01(\v2\x14.cedar.v4.ExprRecordH\x00R\x06record\x12D\n" +
	"\x0eextension_call\x18\x1d \x01(\v2\x1b.cedar.v4.ExprExtensionCallH\x00R\rextensionCall\x12/\n" +
	"\aget_tag\x18\x1e \x01(\v2\x14.cedar.v4.ExprGetTagH\x00R\x06getTag\x12/\n" +
	"\ahas_tag\x18\x1f \x01(\v2\x14.cedar.v4.ExprHasTagH\x00R\x06hasTagB\x06\n" +
	"\x04expr\"2\n" +
	"\tExprValue\x12%\n" +
	"\x05value\x18\x01 \x01(\v2\x0f.cedar.v4.ValueR\x05value\">\n" +
	"\fExprVariable\x12.\n" +
	"\bvariable\x18\x01 \x01(\x0e2\x12.cedar.v4.VariableR\bvariable\"5\n" +
	"\bExprSlot\x12)\n" +
	"\aslot_id\x18\x01 \x01(\x0e2\x10.cedar.v4.SlotIdR\x06slotId\"!\n" +
	"\vExprUnknown\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\"+\n" +
	"\aExprNot\x12 \n" +
	"\x03arg\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x03arg\".\n" +
	"\n" +
	"ExprNegate\x12 \n" +
	"\x03arg\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x03arg\"V\n" +
	"\n" +
	"ExprEquals\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"Y\n" +
	"\rExprNotEquals\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"R\n" +
	"\x06ExprIn\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"X\n" +
	"\fExprLessThan\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"`\n" +
	"\x14ExprLessThanOrEquals\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"[\n" +
	"\x0fExprGreaterThan\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"c\n" +
	"\x17ExprGreaterThanOrEquals\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"S\n" +
	"\aExprAnd\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"R\n" +
	"\x06ExprOr\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"S\n" +
	"\aExprAdd\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"T\n" +
	"\bExprSubt\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"T\n" +
	"\bExprMult\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"X\n" +
	"\fExprContains\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"[\n" +
	"\x0fExprContainsAll\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"[\n" +
	"\x0fExprContainsAny\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12$\n" +
	"\x05right\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05right\"J\n" +
	"\x10ExprGetAttribute\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12\x12\n" +
	"\x04attr\x18\x02 \x01(\tR\x04attr\"J\n" +
	"\x10ExprHasAttribute\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12\x12\n" +
	"\x04attr\x18\x02 \x01(\tR\x04attr\"R\n" +
	"\n" +
	"ExprGetTag\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12 \n" +
	"\x03tag\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x03tag\"R\n" +
	"\n" +
	"ExprHasTag\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12 \n" +
	"\x03tag\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x03tag\"H\n" +
	"\bExprLike\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12\x18\n" +
	"\apattern\x18\x02 \x01(\tR\apattern\"\x83\x01\n" +
	"\x06ExprIs\x12\"\n" +
	"\x04left\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04left\x12\x1f\n" +
	"\ventity_type\x18\x02 \x01(\tR\n" +
	"entityType\x12-\n" +
	"\x02in\x18\x03 \x01(\v2\x0e.cedar.v4.ExprB\b\xba\x8f\xbem\x03in_H\x00R\x02in\x88\x01\x01B\x05\n" +
	"\x03_in\"\x86\x01\n" +
	"\x0eExprIfThenElse\x12\"\n" +
	"\x04cond\x18\x01 \x01(\v2\x0e.cedar.v4.ExprR\x04cond\x12\"\n" +
	"\x04then\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x04then\x12,\n" +
	"\totherwise\x18\x03 \x01(\v2\x0e.cedar.v4.ExprR\totherwise\";\n" +
	"\aExprSet\x120\n" +
	"\vexpressions\x18\x01 \x03(\v2\x0e.cedar.v4.ExprR\vexpressions\"\xa1\x01\n" +
	"\n" +
	"ExprRecord\x12D\n" +
	"\n" +
	"attributes\x18\x01 \x03(\v2$.cedar.v4.ExprRecord.AttributesEntryR\n" +
	"attributes\x1aM\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.cedar.v4.ExprR\x05value:\x028\x01\"G\n" +
	"\x11ExprExtensionCall\x12\x0e\n" +
	"\x02fn\x18\x01 \x01(\tR\x02fn\x12\"\n" +
	"\x04args\x18\x02 \x03(\v2\x0e.cedar.v4.ExprR\x04args*~\n" +
	"\bVariable\x12\x18\n" +
	"\x14VARIABLE_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12VARIABLE_PRINCIPAL\x10\x01\x12\x13\n" +
	"\x0fVARIABLE_ACTION\x10\x02\x12\x15\n" +
	"\x11VARIABLE_RESOURCE\x10\x03\x12\x14\n" +
	"\x10VARIABLE_CONTEXT\x10\x04*N\n" +
	"\x06SlotId\x12\x17\n" +
	"\x13SLOT_ID_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11SLOT_ID_PRINCIPAL\x10\x01\x12\x14\n" +
	"\x10SLOT_ID_RESOURCE\x10\x02B\x91\x01\n" +
	"\fcom.cedar.v4B\tExprProtoP\x01Z5github.com/celest-dev/corks/go/proto/cedar/v4;cedarv4\xa2\x02\x03CXX\xaa\x02\bCedar.V4\xca\x02\bCedar\\V4\xe2\x02\x14Cedar\\V4\\GPBMetadata\xea\x02\tCedar::V4b\x06proto3"

var (
	file_cedar_v4_expr_proto_rawDescOnce sync.Once
	file_cedar_v4_expr_proto_rawDescData []byte
)

func file_cedar_v4_expr_proto_rawDescGZIP() []byte {
	file_cedar_v4_expr_proto_rawDescOnce.Do(func() {
		file_cedar_v4_expr_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cedar_v4_expr_proto_rawDesc), len(file_cedar_v4_expr_proto_rawDesc)))
	})
	return file_cedar_v4_expr_proto_rawDescData
}

var file_cedar_v4_expr_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_cedar_v4_expr_proto_msgTypes = make([]protoimpl.MessageInfo, 33)
var file_cedar_v4_expr_proto_goTypes = []any{
	(Variable)(0),                   // 0: cedar.v4.Variable
	(SlotId)(0),                     // 1: cedar.v4.SlotId
	(*Expr)(nil),                    // 2: cedar.v4.Expr
	(*ExprValue)(nil),               // 3: cedar.v4.ExprValue
	(*ExprVariable)(nil),            // 4: cedar.v4.ExprVariable
	(*ExprSlot)(nil),                // 5: cedar.v4.ExprSlot
	(*ExprUnknown)(nil),             // 6: cedar.v4.ExprUnknown
	(*ExprNot)(nil),                 // 7: cedar.v4.ExprNot
	(*ExprNegate)(nil),              // 8: cedar.v4.ExprNegate
	(*ExprEquals)(nil),              // 9: cedar.v4.ExprEquals
	(*ExprNotEquals)(nil),           // 10: cedar.v4.ExprNotEquals
	(*ExprIn)(nil),                  // 11: cedar.v4.ExprIn
	(*ExprLessThan)(nil),            // 12: cedar.v4.ExprLessThan
	(*ExprLessThanOrEquals)(nil),    // 13: cedar.v4.ExprLessThanOrEquals
	(*ExprGreaterThan)(nil),         // 14: cedar.v4.ExprGreaterThan
	(*ExprGreaterThanOrEquals)(nil), // 15: cedar.v4.ExprGreaterThanOrEquals
	(*ExprAnd)(nil),                 // 16: cedar.v4.ExprAnd
	(*ExprOr)(nil),                  // 17: cedar.v4.ExprOr
	(*ExprAdd)(nil),                 // 18: cedar.v4.ExprAdd
	(*ExprSubt)(nil),                // 19: cedar.v4.ExprSubt
	(*ExprMult)(nil),                // 20: cedar.v4.ExprMult
	(*ExprContains)(nil),            // 21: cedar.v4.ExprContains
	(*ExprContainsAll)(nil),         // 22: cedar.v4.ExprContainsAll
	(*ExprContainsAny)(nil),         // 23: cedar.v4.ExprContainsAny
	(*ExprGetAttribute)(nil),        // 24: cedar.v4.ExprGetAttribute
	(*ExprHasAttribute)(nil),        // 25: cedar.v4.ExprHasAttribute
	(*ExprGetTag)(nil),              // 26: cedar.v4.ExprGetTag
	(*ExprHasTag)(nil),              // 27: cedar.v4.ExprHasTag
	(*ExprLike)(nil),                // 28: cedar.v4.ExprLike
	(*ExprIs)(nil),                  // 29: cedar.v4.ExprIs
	(*ExprIfThenElse)(nil),          // 30: cedar.v4.ExprIfThenElse
	(*ExprSet)(nil),                 // 31: cedar.v4.ExprSet
	(*ExprRecord)(nil),              // 32: cedar.v4.ExprRecord
	(*ExprExtensionCall)(nil),       // 33: cedar.v4.ExprExtensionCall
	nil,                             // 34: cedar.v4.ExprRecord.AttributesEntry
	(*Value)(nil),                   // 35: cedar.v4.Value
}
var file_cedar_v4_expr_proto_depIdxs = []int32{
	3,  // 0: cedar.v4.Expr.value:type_name -> cedar.v4.ExprValue
	4,  // 1: cedar.v4.Expr.variable:type_name -> cedar.v4.ExprVariable
	5,  // 2: cedar.v4.Expr.slot:type_name -> cedar.v4.ExprSlot
	6,  // 3: cedar.v4.Expr.unknown:type_name -> cedar.v4.ExprUnknown
	7,  // 4: cedar.v4.Expr.not:type_name -> cedar.v4.ExprNot
	8,  // 5: cedar.v4.Expr.negate:type_name -> cedar.v4.ExprNegate
	9,  // 6: cedar.v4.Expr.equals:type_name -> cedar.v4.ExprEquals
	10, // 7: cedar.v4.Expr.not_equals:type_name -> cedar.v4.ExprNotEquals
	11, // 8: cedar.v4.Expr.in:type_name -> cedar.v4.ExprIn
	12, // 9: cedar.v4.Expr.less_than:type_name -> cedar.v4.ExprLessThan
	13, // 10: cedar.v4.Expr.less_than_or_equals:type_name -> cedar.v4.ExprLessThanOrEquals
	14, // 11: cedar.v4.Expr.greater_than:type_name -> cedar.v4.ExprGreaterThan
	15, // 12: cedar.v4.Expr.greater_than_or_equals:type_name -> cedar.v4.ExprGreaterThanOrEquals
	16, // 13: cedar.v4.Expr.and:type_name -> cedar.v4.ExprAnd
	17, // 14: cedar.v4.Expr.or:type_name -> cedar.v4.ExprOr
	18, // 15: cedar.v4.Expr.add:type_name -> cedar.v4.ExprAdd
	19, // 16: cedar.v4.Expr.subtract:type_name -> cedar.v4.ExprSubt
	20, // 17: cedar.v4.Expr.multiply:type_name -> cedar.v4.ExprMult
	21, // 18: cedar.v4.Expr.contains:type_name -> cedar.v4.ExprContains
	22, // 19: cedar.v4.Expr.contains_all:type_name -> cedar.v4.ExprContainsAll
	23, // 20: cedar.v4.Expr.contains_any:type_name -> cedar.v4.ExprContainsAny
	24, // 21: cedar.v4.Expr.get_attribute:type_name -> cedar.v4.ExprGetAttribute
	25, // 22: cedar.v4.Expr.has_attribute:type_name -> cedar.v4.ExprHasAttribute
	28, // 23: cedar.v4.Expr.like:type_name -> cedar.v4.ExprLike
	29, // 24: cedar.v4.Expr.is:type_name -> cedar.v4.ExprIs
	30, // 25: cedar.v4.Expr.if_then_else:type_name -> cedar.v4.ExprIfThenElse
	31, // 26: cedar.v4.Expr.set:type_name -> cedar.v4.ExprSet
	32, // 27: cedar.v4.Expr.record:type_name -> cedar.v4.ExprRecord
	33, // 28: cedar.v4.Expr.extension_call:type_name -> cedar.v4.ExprExtensionCall
	26, // 29: cedar.v4.Expr.get_tag:type_name -> cedar.v4.ExprGetTag
	27, // 30: cedar.v4.Expr.has_tag:type_name -> cedar.v4.ExprHasTag
	35, // 31: cedar.v4.ExprValue.value:type_name -> cedar.v4.Value
	0,  // 32: cedar.v4.ExprVariable.variable:type_name -> cedar.v4.Variable
	1,  // 33: cedar.v4.ExprSlot.slot_id:type_name -> cedar.v4.SlotId
	2,  // 34: cedar.v4.ExprNot.arg:type_name -> cedar.v4.Expr
	2,  // 35: cedar.v4.ExprNegate.arg:type_name -> cedar.v4.Expr
	2,  // 36: cedar.v4.ExprEquals.left:type_name -> cedar.v4.Expr
	2,  // 37: cedar.v4.ExprEquals.right:type_name -> cedar.v4.Expr
	2,  // 38: cedar.v4.ExprNotEquals.left:type_name -> cedar.v4.Expr
	2,  // 39: cedar.v4.ExprNotEquals.right:type_name -> cedar.v4.Expr
	2,  // 40: cedar.v4.ExprIn.left:type_name -> cedar.v4.Expr
	2,  // 41: cedar.v4.ExprIn.right:type_name -> cedar.v4.Expr
	2,  // 42: cedar.v4.ExprLessThan.left:type_name -> cedar.v4.Expr
	2,  // 43: cedar.v4.ExprLessThan.right:type_name -> cedar.v4.Expr
	2,  // 44: cedar.v4.ExprLessThanOrEquals.left:type_name -> cedar.v4.Expr
	2,  // 45: cedar.v4.ExprLessThanOrEquals.right:type_name -> cedar.v4.Expr
	2,  // 46: cedar.v4.ExprGreaterThan.left:type_name -> cedar.v4.Expr
	2,  // 47: cedar.v4.ExprGreaterThan.right:type_name -> cedar.v4.Expr
	2,  // 48: cedar.v4.ExprGreaterThanOrEquals.left:type_name -> cedar.v4.Expr
	2,  // 49: cedar.v4.ExprGreaterThanOrEquals.right:type_name -> cedar.v4.Expr
	2,  // 50: cedar.v4.ExprAnd.left:type_name -> cedar.v4.Expr
	2,  // 51: cedar.v4.ExprAnd.right:type_name -> cedar.v4.Expr
	2,  // 52: cedar.v4.ExprOr.left:type_name -> cedar.v4.Expr
	2,  // 53: cedar.v4.ExprOr.right:type_name -> cedar.v4.Expr
	2,  // 54: cedar.v4.ExprAdd.left:type_name -> cedar.v4.Expr
	2,  // 55: cedar.v4.ExprAdd.right:type_name -> cedar.v4.Expr
	2,  // 56: cedar.v4.ExprSubt.left:type_name -> cedar.v4.Expr
	2,  // 57: cedar.v4.ExprSubt.right:type_name -> cedar.v4.Expr
	2,  // 58: cedar.v4.ExprMult.left:type_name -> cedar.v4.Expr
	2,  // 59: cedar.v4.ExprMult.right:type_name -> cedar.v4.Expr
	2,  // 60: cedar.v4.ExprContains.left:type_name -> cedar.v4.Expr
	2,  // 61: cedar.v4.ExprContains.right:type_name -> cedar.v4.Expr
	2,  // 62: cedar.v4.ExprContainsAll.left:type_name -> cedar.v4.Expr
	2,  // 63: cedar.v4.ExprContainsAll.right:type_name -> cedar.v4.Expr
	2,  // 64: cedar.v4.ExprContainsAny.left:type_name -> cedar.v4.Expr
	2,  // 65: cedar.v4.ExprContainsAny.right:type_name -> cedar.v4.Expr
	2,  // 66: cedar.v4.ExprGetAttribute.left:type_name -> cedar.v4.Expr
	2,  // 67: cedar.v4.ExprHasAttribute.left:type_name -> cedar.v4.Expr
	2,  // 68: cedar.v4.ExprGetTag.left:type_name -> cedar.v4.Expr
	2,  // 69: cedar.v4.ExprGetTag.tag:type_name -> cedar.v4.Expr
	2,  // 70: cedar.v4.ExprHasTag.left:type_name -> cedar.v4.Expr
	2,  // 71: cedar.v4.ExprHasTag.tag:type_name -> cedar.v4.Expr
	2,  // 72: cedar.v4.ExprLike.left:type_name -> cedar.v4.Expr
	2,  // 73: cedar.v4.ExprIs.left:type_name -> cedar.v4.Expr
	2,  // 74: cedar.v4.ExprIs.in:type_name -> cedar.v4.Expr
	2,  // 75: cedar.v4.ExprIfThenElse.cond:type_name -> cedar.v4.Expr
	2,  // 76: cedar.v4.ExprIfThenElse.then:type_name -> cedar.v4.Expr
	2,  // 77: cedar.v4.ExprIfThenElse.otherwise:type_name -> cedar.v4.Expr
	2,  // 78: cedar.v4.ExprSet.expressions:type_name -> cedar.v4.Expr
	34, // 79: cedar.v4.ExprRecord.attributes:type_name -> cedar.v4.ExprRecord.AttributesEntry
	2,  // 80: cedar.v4.ExprExtensionCall.args:type_name -> cedar.v4.Expr
	2,  // 81: cedar.v4.ExprRecord.AttributesEntry.value:type_name -> cedar.v4.Expr
	82, // [82:82] is the sub-list for method output_type
	82, // [82:82] is the sub-list for method input_type
	82, // [82:82] is the sub-list for extension type_name
	82, // [82:82] is the sub-list for extension extendee
	0,  // [0:82] is the sub-list for field type_name
}

func init() { file_cedar_v4_expr_proto_init() }
func file_cedar_v4_expr_proto_init() {
	if File_cedar_v4_expr_proto != nil {
		return
	}
	file_cedar_v4_value_proto_init()
	file_cedar_v4_expr_proto_msgTypes[0].OneofWrappers = []any{
		(*Expr_Value)(nil),
		(*Expr_Variable)(nil),
		(*Expr_Slot)(nil),
		(*Expr_Unknown)(nil),
		(*Expr_Not)(nil),
		(*Expr_Negate)(nil),
		(*Expr_Equals)(nil),
		(*Expr_NotEquals)(nil),
		(*Expr_In)(nil),
		(*Expr_LessThan)(nil),
		(*Expr_LessThanOrEquals)(nil),
		(*Expr_GreaterThan)(nil),
		(*Expr_GreaterThanOrEquals)(nil),
		(*Expr_And)(nil),
		(*Expr_Or)(nil),
		(*Expr_Add)(nil),
		(*Expr_Subtract)(nil),
		(*Expr_Multiply)(nil),
		(*Expr_Contains)(nil),
		(*Expr_ContainsAll)(nil),
		(*Expr_ContainsAny)(nil),
		(*Expr_GetAttribute)(nil),
		(*Expr_HasAttribute)(nil),
		(*Expr_Like)(nil),
		(*Expr_Is)(nil),
		(*Expr_IfThenElse)(nil),
		(*Expr_Set)(nil),
		(*Expr_Record)(nil),
		(*Expr_ExtensionCall)(nil),
		(*Expr_GetTag)(nil),
		(*Expr_HasTag)(nil),
	}
	file_cedar_v4_expr_proto_msgTypes[27].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cedar_v4_expr_proto_rawDesc), len(file_cedar_v4_expr_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   33,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cedar_v4_expr_proto_goTypes,
		DependencyIndexes: file_cedar_v4_expr_proto_depIdxs,
		EnumInfos:         file_cedar_v4_expr_proto_enumTypes,
		MessageInfos:      file_cedar_v4_expr_proto_msgTypes,
	}.Build()
	File_cedar_v4_expr_proto = out.File
	file_cedar_v4_expr_proto_goTypes = nil
	file_cedar_v4_expr_proto_depIdxs = nil
}
